Xminusj <- X[,-j]
Pminusj <- Xminusj%*%solve(crossprod(Xminusj))%*%t(Xminusj)
tildeXj <- (diag(nrow(X)) - Pminusj)%*%Xj
tildeXj%*%solve(crossprod(tildeXj))%*%t(tildeXj)
})
vecs <- c(vT, Pg)
vecs <- vecs[order(c(singles,facs))]
nam <- attr(limo$terms, "term.labels")
if("(Intercept)"%in%colnames(X)) nam <- c("(Intercept)", nam)
names(vecs) <- nam
str(vecs,1)
vt <- vecs[[6]]
str( t(vt)%*%vt / as.numeric(vt%*%t(vt)),1)
?AIC
AIC.default
stats:::AIC.default
setwd("Dropbox/coinflibs/")
library(devtools)
document()
document()
document()
check()
check()
load_all()
library(MASS)
cpus$perf <- log10(cpus$perf)
data("cpus")
cpus$perf <- log10(cpus$perf)
mod <- lm(perf ~ .-name, data = cpus)
cpus.lm <- stepAIC(mod, trace = FALSE, direction = "backward")
lom <- c(lapply(colnames(model.matrix(mod)), function(x)
update(mod, as.formula(paste0("perf ~ .-", x)))), list(mod))
compsAIC <- extract_components(listOfModels = lom,
response = cpus$perf,
what = c("aic"))
alpha = 0.001
coefTable <- summary(cpus.lm)$coefficients
drop <- rownames(coefTable)[alpha < coefTable[,4]]
cpus.lm2 <- update(cpus.lm, as.formula(paste0(".~.-",drop)))
compsLRT <- extract_components(list(cpus.lm, cpus.lm2),
response = cpus$perf,
what = "lrt",
alpha = alpha)
vTs <- extract_testvec(cpus.lm2)
limitsAIC <- calculate_limits(compsAIC, vTs)
debug(calculate_limits)
limitsAIC <- calculate_limits(compsAIC, vTs)
str(vTs,1)
str(vTs,1)
debug(extract_testvec)
vTs <- extract_testvec(cpus.lm2)
install_github("davidruegamer/coinflibs")
library(coinflibs)
vTs <- extract_testvec(cpus.lm2)
source('~/Dropbox/coinflibs/R/lm_functions.R', echo=TRUE)
vTs <- extract_testvec(cpus.lm2)
str(vTs,1)
check()
vTs <- extract_testvec(cpus.lm2)
str(vTs,1)
limitsAIC <- calculate_limits(compsAIC, vTs)
debug(calculate_limits)
limitsAIC <- calculate_limits(compsAIC, vTs)
str(vTs,1)
sapply(vTs,nrow)
str(Pv,1)
source('~/Dropbox/coinflibs/R/lm_functions.R', echo=TRUE)
limitsAIC <- calculate_limits(compsAIC, vTs)
check()
cpus$perf <- log10(cpus$perf)
mod <- lm(perf ~ .-name, data = cpus)
cpus.lm <- stepAIC(mod, trace = FALSE, direction = "backward")
lom <- c(lapply(colnames(model.matrix(mod)), function(x)
update(mod, as.formula(paste0("perf ~ .-", x)))), list(mod))
alpha = 0.001
coefTable <- summary(cpus.lm)$coefficients
drop <- rownames(coefTable)[alpha < coefTable[,4]]
cpus.lm2 <- update(cpus.lm, as.formula(paste0(".~.-",drop)))
cpus$chmin <- as.factor(cpus$chmin)
mod <- lm(perf ~ .-name, data = cpus)
cpus.lm <- stepAIC(mod, trace = FALSE, direction = "backward")
cpus.lm
mod <- lm(perf ~ .-name, data = cpus)
mod <- lm(perf ~ .-name, data = cpus)
cpus.lm <- stepAIC(mod, trace = FALSE, direction = "backward")
# recalculate all visited models
lom <- c(lapply(colnames(model.matrix(mod)), function(x)
update(mod, as.formula(paste0("perf ~ .-", x)))), list(mod))
# perform likelihood ratio test at level
alpha = 0.001
# check for non-significant variables
coefTable <- summary(cpus.lm)$coefficients
drop <- rownames(coefTable)[alpha < coefTable[,4]]
# drop non-significant variable
cpus.lm2 <- update(cpus.lm, as.formula(paste0(".~.-",drop)))
str(lom,1)
?stepAIC
cpus.lm <- stepAIC(mod, trace = FALSE, direction = "backward", steps = 2)
str(cpus.lm$anova)
mod
attr(mod$terms, "term.labels")
lom <- c(lapply(attr(mod$terms, "term.labels"), function(x)
lom1 <- c(lapply(attr(mod$terms, "term.labels"), function(x)
update(mod, as.formula(paste0("perf ~ .-", x)))), list(mod))
str(lom1,1)
cpus.lm
cpus.lm$anova$Steps
str(cpus.lm$anova$Step)
head(cpis)
head(cpus)
sapply(cpus, function(x)length(unique(x)))
cpus$cach <- as.factor(cpus$cach)
mod <- lm(perf ~ .-name, data = cpus)
cpus.lm <- stepAIC(mod, trace = FALSE, direction = "backward", steps = 2)
cpus.lm$anova$Steps
cpus.lm$anova$Step
lom1 <- c(lapply(attr(mod$terms, "term.labels"), function(x)
cpus.lm <- stepAIC(mod, trace = FALSE, direction = "backward", steps = 3)
cpus.lm$anova$Step
cpus.lm <- stepAIC(mod, trace = FALSE, direction = "backward", steps = 3)
# check model selection
cpus.lm$anova$Step
lom1 <- c(lapply(attr(mod$terms, "term.labels"), function(x)
update(mod, as.formula(paste0("perf ~ .-", x)))), list(mod))
str(lom1,1)
alpha = 0.001
coefTable <- summary(cpus.lm)$coefficients
coefTable
anova(cpus.lm)
str(anova(cpus.lm))
coefTable <- anova(cpus.lm)
rownames(coefTable)[alpha < coefTable[,5]]
coefTable
rownames(coefTable)[alpha < coefTable[-nrow(coefTable),5]]
drop <- rownames(coefTable)[alpha < coefTable[-nrow(coefTable),5]]
cpus.lm2 <- update(cpus.lm, as.formula(paste0(".~.-",drop)))
selinf(list(cpus.lm1, cpus.lm2), lom1, what = c("aic", "Ftest"),
sd = summary(cpus.lm2)$sigma)
selinf(list(cpus.lm, cpus.lm2), lom1, what = c("aic", "Ftest"),
sd = summary(cpus.lm2)$sigma)
source('~/Dropbox/coinflibs/R/selinf.R', echo=TRUE)
selinf(list(cpus.lm, cpus.lm2), lom1, what = c("aic", "Ftest"),
sd = summary(cpus.lm2)$sigma)
debug(selinf)
selinf(list(cpus.lm, cpus.lm2), lom1, what = c("aic", "Ftest"),
sd = summary(cpus.lm2)$sigma)
list(1:5)
list(1:5, list(1:5))
list(1:5, list(a=1:5,b=2))
source('~/Dropbox/coinflibs/R/selinf.R', echo=TRUE)
selinf(list(cpus.lm, cpus.lm2), lom1, what = c("aic", "Ftest"),
sd = summary(cpus.lm2)$sigma)
cpus.lm
selinf(list(cpus.lm, cpus.lm2), lom1,
response = cpus$perf,
what = c("aic", "Ftest"),
sd = summary(cpus.lm2)$sigma)
library(intervals)
selinf(list(cpus.lm, cpus.lm2), lom1,
response = cpus$perf,
what = c("aic", "Ftest"),
sd = summary(cpus.lm2)$sigma)
traceback()
debug(getBoundsPen)
selinf(list(cpus.lm, cpus.lm2), lom1,
response = cpus$perf,
what = c("aic", "Ftest"),
sd = summary(cpus.lm2)$sigma)
taus
taus
str(pv.1)
str(pv,1)
str(pvo,1)
str(Ugtilde)
TV
TC
taus <- solveQuadIneq(A=A, c=c, Pv=pv, PvO = pvo, y=y)
taus
mu <- as.numeric(vt%*%y)
mu
str(vt,1)
vt <- t(y)%*%pv
mu <- as.numeric(vt%*%y)
mu
Vlo <- mu*taus[1]
Vup <- mu*taus[2]
Vlo
Vup
!is.null(pvo)
mu <- mu*TC
mu
mu <- as.numeric(vt%*%y)
mu*TC^2
vt <- t(y)%*%pv / TC
mu <- as.numeric(vt%*%y)
Vlo <- mu*taus[1]
Vup <- mu*taus[2]
Vlo
Vup
mu*TC^2
taus
TC
calcA <- function(n, p1, p2, pen1, pen2, Px1, Px2){
diag(Px2) <- 1-diag(Px2)
diag(Px1) <- 1-diag(Px1)
return(
(n-p1) * exp( -(p1 - p2 + pen1 - pen2)/n ) * Px2 - (n-p2) * Px1
)
}
bestInd=2
(1:2)!=bestInd
which((1:2)!=bestInd)
source('~/Dropbox/coinflibs/R/lm_functions.R', echo=TRUE)
source('~/Dropbox/coinflibs/R/lm_functions.R', echo=TRUE)
set.seed(42)
y <- rnorm(10)
x <- runif(10)
mod1 <- lm(y ~ x)
x2 <- runif(10)
mod2 <- lm(y ~ x2)
AIC(mod1,mod2)
lom <- list(mod1, mod2)
# get components
comps <- extract_components(lom, response = y)
str(comps,1)
str(comps$A,1)
t(comps$y)%*%comps$A%*%comps$y
(comps$y)%*%comps$A%*%t(comps$y)
t(comps$y)%*%comps$A[[1]]%*%comps$y
source('~/Dropbox/coinflibs/R/lm_functions.R', echo=TRUE)
set.seed(42)
y <- rnorm(10)
x <- runif(10)
mod1 <- lm(y ~ x)
x2 <- runif(10)
mod2 <- lm(y ~ x2)
AIC(mod1,mod2)
lom <- list(mod1, mod2)
# get components
comps <- extract_components(lom, response = y)
str(comps,1)
t(comps$y)%*%comps$A[[1]]%*%comps$y
BIC(mod1,mod2)
comps <- extract_components(lom, response = y, what = "bic")
str(comps,1)
t(comps$y)%*%comps$A[[1]]%*%comps$y
debug(extract_components)
comps <- extract_components(lom, response = y, what = "bic")
pens
critvals <- do.call("AIC", listOfModels)
bestInd <- which.min(critvals$AIC)
pens <- 2*critvals$df
pens
logLik(mod1)
load_all("")
load_all(".")
load_all(".")
library(MASS)
# Fit initial model
cpus$perf <- log10(cpus$perf)
cpus$chmin <- as.factor(cpus$chmin)
cpus$cach <- as.factor(cpus$cach)
data("cpus")
# Fit initial model
cpus$perf <- log10(cpus$perf)
cpus$chmin <- as.factor(cpus$chmin)
cpus$cach <- as.factor(cpus$cach)
mod <- lm(perf ~ .-name, data = cpus)
# use the stepAIC function to find the best model in a backward
# stepwise search
cpus.lm <- stepAIC(mod, trace = FALSE, direction = "backward", steps = 3)
# check model selection
cpus.lm$anova$Step
# recalculate all visited models in the first step
lom1 <- c(lapply(attr(mod$terms, "term.labels"), function(x)
cpus.lm$anova$Step
cpus.lm$anova$Step
library(MASS)
data("cpus")
# Fit initial model
cpus$perf <- log10(cpus$perf)
cpus$chmin <- as.factor(cpus$chmin)
cpus$cach <- as.factor(cpus$cach)
mod <- lm(perf ~ .-name, data = cpus)
mod
cpus.lm <- stepAIC(mod, trace = FALSE, direction = "backward", steps = 3)
# check model selection
cpus.lm$anova$Step
data("cpus")
# Fit initial model
cpus$perf <- log10(cpus$perf)
cpus$cach <- as.factor(cpus$cach)
mod <- lm(perf ~ .-name, data = cpus)
# use the stepAIC function to find the best model in a backward
# stepwise search
cpus.lm <- stepAIC(mod, trace = FALSE, direction = "backward", steps = 3)
# check model selection
cpus.lm$anova$Step
# recalculate all visited models in the first step
lom1 <- c(lapply(attr(mod$terms, "term.labels"), function(x)
update(mod, as.formula(paste0("perf ~ .-", x)))), list(mod))
# perform likelihood ratio test at level
alpha = 0.001
# check for non-significant variables
coefTable <- anova(cpus.lm)
drop <- rownames(coefTable)[alpha < coefTable[-nrow(coefTable),5]]
drop
cpus.lm2 <- update(cpus.lm, as.formula(paste0(".~.-",drop)))
# compute selective inference
selinf(list(cpus.lm, cpus.lm2), lom1,
response = cpus$perf,
what = c("aic", "Ftest"),
sd = summary(cpus.lm2)$sigma)
source('~/Dropbox/coinflibs/R/lm_functions.R', echo=TRUE)
selinf(list(cpus.lm, cpus.lm2), lom1,
response = cpus$perf,
what = c("aic", "Ftest"),
sd = summary(cpus.lm2)$sigma)
source('~/Dropbox/coinflibs/R/selinf.R', echo=TRUE)
selinf(list(cpus.lm, cpus.lm2), lom1,
response = cpus$perf,
what = c("aic", "Ftest"),
sd = summary(cpus.lm2)$sigma)
traceback()
debug(selinf)
selinf(list(cpus.lm, cpus.lm2), lom1,
response = cpus$perf,
what = c("aic", "Ftest"),
sd = summary(cpus.lm2)$sigma)
source('~/Dropbox/coinflibs/R/lm_functions.R', echo=TRUE)
source('~/Dropbox/coinflibs/R/lm_functions.R', echo=TRUE)
# compute selective inference
selinf(list(cpus.lm, cpus.lm2), lom1,
response = cpus$perf,
what = c("aic", "Ftest"),
sd = summary(cpus.lm2)$sigma)
lim1
str(lim1)
str(lim1,1)
selinf(list(cpus.lm, cpus.lm2), lom1,
response = cpus$perf,
what = c("aic", "Ftest"),
sd = summary(cpus.lm2)$sigma)
what
length(ll)
what
extract_components()
debug(extract_components)
length(ll)
i=1
listItem <- ll[[i]]
comps <- extract_components(listOfModels = listItem,
response = response,
what = what[[i+1]],
REML = REML,
alpha = alpha, df = df)
str(listOfModels,1)
# compute selective inference
selinf(list(cpus.lm, cpus.lm2), lom1,
response = cpus$perf,
what = c("aic", "Ftest"),
sd = summary(cpus.lm2)$sigma)
str(listOfModels,1)
str(ll,1)
str(ll[[1]],1)
# compute selective inference
selinf(list(cpus.lm, cpus.lm2), lom1,
response = cpus$perf,
what = c("Ftest", "aic"),
sd = summary(cpus.lm2)$sigma)
str(A,1)
source('~/Dropbox/coinflibs/R/lm_functions.R', echo=TRUE)
selinf(list(cpus.lm, cpus.lm2), lom1,
response = cpus$perf,
what = c("Ftest", "aic"),
sd = summary(cpus.lm2)$sigma)
lim1
str(lim1,1)
what
str(limits,1)
str(limits,1)
str(limits,2)
limits
traceback()
debug(combine_limitObjects)
# compute selective inference
selinf(list(cpus.lm, cpus.lm2), lom1,
response = cpus$perf,
what = c("Ftest", "aic"),
sd = summary(cpus.lm2)$sigma)
str(listOfLimitObjects,1)
str(listOfLimitObjects,2)
for(nam in names){
limits <- lapply(listOfLimitObjects, function(x) x[[nam]])
vT <- limits[[1]]$vT
limits <- do.call("interval_intersection", lapply(limits, "[[", "limits"))
if(!any(sapply(1:nrow(limits),function(i)
xinInt(x = as.numeric(vT%*%y), int = limits[i,]))))
stop("Wrong limits. No interval does include the actual value of interest.")
}
names
for(nam in names){
limits <- lapply(listOfLimitObjects, function(x) x[[nam]])
vT <- limits[[1]]$vT
limits <- do.call("interval_intersection", lapply(limits, "[[", "limits"))
if(!any(sapply(1:nrow(limits),function(i)
xinInt(x = as.numeric(vT%*%y), int = limits[i,]))))
stop("Wrong limits. No interval does include the actual value of interest.")
}
nam
nam="cach"
limits <- lapply(listOfLimitObjects, function(x) x[[nam]])
limits
str(limits,1)
str(limits,2)
limits <- do.call("interval_intersection", lapply(limits, "[[", "limits"))
str(limits,1)
limits
vT <- limits[[1]]$vT
str(vT,1)
vT%*%y
str(vT,1)
limits
str(listOfLimitObjects,1)
str(listOfLimitObjects,2)
str(listOfLimitObjects,3)
debug(calculate_selinf)
# compute selective inference
selinf(list(cpus.lm, cpus.lm2), lom1,
response = cpus$perf,
what = c("Ftest", "aic"),
sd = summary(cpus.lm2)$sigma)
str(limitObject,2)
str(limitObject,3)
cpus.lm
source('~/Dropbox/coinflibs/R/selinf.R', echo=TRUE)
selinf(list(cpus.lm, cpus.lm2), lom1,
response = cpus$perf,
what = c("Ftest", "aic"),
sd = summary(cpus.lm2)$sigma)
source('~/Dropbox/coinflibs/R/p-value_calculation.R', echo=TRUE)
# compute selective inference
selinf(list(cpus.lm, cpus.lm2), lom1,
response = cpus$perf,
what = c("Ftest", "aic"),
sd = summary(cpus.lm2)$sigma)
str(vT,1)
source('~/Dropbox/coinflibs/R/p-value_calculation.R', echo=TRUE)
selinf(list(cpus.lm, cpus.lm2), lom1,
response = cpus$perf,
what = c("Ftest", "aic"),
sd = summary(cpus.lm2)$sigma)
library(msm)
selinf(list(cpus.lm, cpus.lm2), lom1,
response = cpus$perf,
what = c("Ftest", "aic"),
sd = summary(cpus.lm2)$sigma)
tt <- extract_testvec(cpus.lm2)
str(tt,1)
sum(diag(tt$cach))
source('~/Dropbox/coinflibs/R/selinf.R', echo=TRUE)
debug(calculate_selinf)
selinf(list(cpus.lm, cpus.lm2), lom1,
response = cpus$perf,
what = c("Ftest", "aic"),
sd = summary(cpus.lm2)$sigma)
source('~/Dropbox/coinflibs/R/selinf.R', echo=TRUE)
source('~/Dropbox/coinflibs/R/selinf.R', echo=TRUE)
debug(calculate_selinf)
selinf(list(cpus.lm, cpus.lm2), lom1,
response = cpus$perf,
what = c("Ftest", "aic"),
sd = summary(cpus.lm2)$sigma)
ests
ests[j]
source('~/Dropbox/coinflibs/R/p-value_calculation.R', echo=TRUE)
TC_surv(TC = ests[j], sigma = sd,
df = sum(diag(vT)), E = limits)
source('~/Dropbox/coinflibs/R/p-value_calculation.R', echo=TRUE)
TC_surv(TC = ests[j], sigma = sd,
df = sum(diag(vT)), E = limits)
source('~/Dropbox/coinflibs/R/p-value_calculation.R', echo=TRUE)
selinf(list(cpus.lm, cpus.lm2), lom1,
response = cpus$perf,
what = c("Ftest", "aic"),
sd = summary(cpus.lm2)$sigma)
str(limitObject,1)
j=5
Ugtilde <- svd(vT)$u
lowLim[j] <- upLim[j] <- NA # tbd
function (x, nu = min(n, p), nv = min(n, p), LINPACK = FALSE)
vT <- limitObject[[j]]$vT
limits <- limitObject[[j]]$limits
Ugtilde <- svd(vT)$u
lowLim[j] <- upLim[j] <- NA # tbd
ests[j] <- sqrt(sum((t(Ugtilde) %*% y)^2))
ests[j]
TC_surv(TC = ests[j], sigma = sd,
df = sum(diag(vT)), E = limits)
limits
sd
sum(diag(vT))
debug(TC_surv)
TC_surv(TC = ests[j], sigma = sd,
df = sum(diag(vT)), E = limits)
TC_surv(TC = ests[j], sigma = sd,
df = sum(diag(vT)), E = limits)
1:nrow(E)
lapply(1:nrow(E), function(v) {
tchi_interval(E[v,1], E[v,2], sigma, df)
})
document()
