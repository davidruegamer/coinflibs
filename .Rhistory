library(devtools)
setwd("..")
devtools::create("coinflibs")
document()
document()
document()
document()
library(intervals)
?Intervals
document()
document()
library(devtools)
load_all(".")
library(MASS)
cpus$perf <- log10(cpus$perf)
mod <- lm(perf ~ .-name, data = cpus)
cpus.lm <- stepAIC(mod, trace = FALSE, direction = "backward")
lom <- c(lapply(colnames(model.matrix(mod)), function(x)
update(mod, as.formula(paste0("perf ~ .-", x)))), list(mod))
compsAIC <- extract_components(listOfModels = lom,
response = cpus$perf,
what = c("aic"))
alpha = 0.001
coefTable <- summary(cpus.lm)$coefficients
drop <- rownames(coefTable)[alpha < coefTable[,4]]
cpus.lm2 <- update(cpus.lm, as.formula(paste0(".~.-",drop)))
compsLRT <- extract_components(list(cpus.lm, cpus.lm2),
response = cpus$perf,
what = "lrt",
alpha = alpha)
unadj_pvs <- summary(cpus.lm2)$coefficients[,4]
vTs <- extract_testvec(cpus.lm2)
limitsAIC <- calculate_limits(compsAIC, vTs)
limitsLRT <- calculate_limits(compsLRT, vTs)
cbind(
calculate_pvals(limitObject = limitsAIC, y = cpus$perf, sd = sigma(cpus.lm2)),
unadjusted_pval = unadj_pvs
)[,c(1,4,2)]
cbind(
calculate_pvals(limitObject = limitsLRT, y = cpus$perf, sd = sigma(cpus.lm2)),
unadjusted_pval = unadj_pvs
)[,c(1,4,2)]
res <- calculate_pvals(limitObject = list(limitsAIC, limitsLRT),
y = cpus$perf,
# plugin estimate for true value
sd = sigma(cpus.lm2))
cbind(res, unadjusted_pval = unadj_pvs)[,c(1,4,2)]
res$teststat
limitsAIC[[1]]$limits
?extract_testvec
document()
document()
check()
document()
check()
check()
check()
?pnorm
check()
check()
document()
check()
check()
check()
check()
library(selectiveInference)
?tnorm.surv
check()
check()
Intervals(c(0,1))
?qtnorm
library(msm)
?qtnorm
qtnorm(c(0.5,0.75))
checK()
check()
document()
check()
check()
?ptnorm
int1 <- Intervals(c(-3,1))
mean = -0.2
ci_tnorm <- function(mean, sd, limits, alpha)
{
limits <- limits[order(limits[,1]),]
pnormstd <- function(x) pnorm((x - mean)/sd)
limitX <- which(limits[,2] > mean & limits[,1] < mean)
denom <- sum(sapply(1:nrow(limits), function(i) pnormstd(limits[i,2]) - pnormstd(limits[i,1])))
massUpper <- pnormstd(limits[limitX,2])
massLower <- pnormstd(limits[limitX,1])
thisQfun <- function(p) qtnorm(p, mean = mean, sd = sd,
lower = limits[limitX, 1],
upper = limits[limitX, 2])
thisCov <- (massUpper - massLower) / denom
### case discrimination
if(thisCov > 1-alpha){
lowdef <- massLower > (alpha/2)
updef <- massUpper < (1-alpha/2)
if(lowdef | updef){
if(lowdef){
lower <- limits[limitX, 1]
upper <- thisQfun(p = 1 - alpha + massLower)
}else{
lower <- thisQfun(p = alpha - (1 - massUpper))
upper <- limits[limitX, 2]
}
return(Intervals(c(lower, upper)))
}else{
return(Intervals(thisQfun(p = c(alpha/2, 1 - alpha/2))))
}
}else{
warning("Can not create one connected confidence interval with ", 1-alpha, " coverage property.\n",
"Returned interval has ", thisCov, " coverage.")
return(limits[limitX,])
}
}
args(ci_tnorm)
selinf <- function(limitObject, y, sd, alpha = 0.05)
{
if(class(limitObject) != "limitObject"){
### list of limitObjects -> combine limits
### stop if that's not the case
if(any(sapply(limitObject, class) != "limitObject"))
stop("limitObject must either be of class 'limitObject' or a list with 'limitObject's")
limitObject <- combine_limitObjects(limitObject)
}
pvals <- lowLim <- upLim <- ests <- rep(NA, length(limitObject))
# calculate p-values for all limitObjects
for(j in 1:length(limitObject)){
vT <- limitObject[[j]]$vT
mu <- as.numeric(vT%*%y)
this_sd <- sd * sqrt(as.numeric(tcrossprod(vT)))
limits <- limitObject[[j]]$limits
pvals[j] <- mult_tnorm_surv(x = mu, mean = 0,
sd = this_sd,
limits = limits)
int <- ci_tnorm(mean = mu, sd = this_sd,
limits = limits, alpha = alpha)
lowLim[j] <- int[1]
upLim[j] <- int[2]
ests[j] <- mu
}
return(
data.frame(varname = names(limitObject),
teststat = ests,
lower = lowLim,
upper = upLim,
pval = pvals,
))
}
limitsAIC
res <- selinf(limitObject = list(limitsAIC, limitsLRT),
y = cpus$perf,
# plugin estimate for true value
sd = sigma(cpus.lm2))
combine_limitObjects <- function(listOfLimitObjects){
names <- unique(c(sapply(listOfLimitObjects, names)))
res <- lapply(names, function(nam){
limits <- lapply(listOfLimitObjects, function(x) x[[nam]])
vT <- limits[[1]]$vT
limits <- do.call("interval_intersection", lapply(limits, "[[", "limits"))
if(!any(sapply(1:nrow(limits),function(i)
xinInt(x = as.numeric(vT%*%y), int = limits[i,]))))
stop("Wrong limits. No interval does include the actual value of interest.")
return(list(vT = vT, limits = limits))
})
names(res) <- names
return(res)
}
res <- selinf(limitObject = list(limitsAIC, limitsLRT),
y = cpus$perf,
# plugin estimate for true value
sd = sigma(cpus.lm2))
combine_limitObjects <- function(listOfLimitObjects){
names <- unique(c(sapply(listOfLimitObjects, names)))
res <- lapply(names, function(nam){
limits <- lapply(listOfLimitObjects, function(x) x[[nam]])
vT <- limits[[1]]$vT
y <- listOfLimitObjects[[1]]$y
limits <- do.call("interval_intersection", lapply(limits, "[[", "limits"))
if(!any(sapply(1:nrow(limits),function(i)
xinInt(x = as.numeric(vT%*%y), int = limits[i,]))))
stop("Wrong limits. No interval does include the actual value of interest.")
return(list(vT = vT, limits = limits))
})
names(res) <- names
return(res)
}
res <- selinf(limitObject = list(limitsAIC, limitsLRT),
y = cpus$perf,
# plugin estimate for true value
sd = sigma(cpus.lm2))
debug(combine_limitObjects)
res <- selinf(limitObject = list(limitsAIC, limitsLRT),
y = cpus$perf,
# plugin estimate for true value
sd = sigma(cpus.lm2))
res <- selinf(limitObject = list(limitsAIC, limitsLRT),
y = cpus$perf,
# plugin estimate for true value
sd = sigma(cpus.lm2))
names
nam = names[1]
limits <- lapply(listOfLimitObjects, function(x) x[[nam]])
vT <- limits[[1]]$vT
y <- listOfLimitObjects[[1]]$y
str(vT,1)
str(y,1)
str(listOfLimitObjects)
str(listOfLimitObjects,1)
str(listOfLimitObjects[[1]],1)
source('~/Dropbox/coinflibs/R/p-value_calculation.R', echo=TRUE)
res <- selinf(limitObject = list(limitsAIC, limitsLRT),
y = cpus$perf,
# plugin estimate for true value
sd = sigma(cpus.lm2))
debug(selinf)
res <- selinf(limitObject = list(limitsAIC, limitsLRT),
y = cpus$perf,
# plugin estimate for true value
sd = sigma(cpus.lm2))
int
mu
int[1]
int[[1]]
source('~/Dropbox/coinflibs/R/p-value_calculation.R', echo=TRUE)
res <- selinf(limitObject = list(limitsAIC, limitsLRT),
y = cpus$perf,
# plugin estimate for true value
sd = sigma(cpus.lm2))
source('~/Dropbox/coinflibs/R/p-value_calculation.R', echo=TRUE)
res <- selinf(limitObject = list(limitsAIC, limitsLRT),
y = cpus$perf,
# plugin estimate for true value
sd = sigma(cpus.lm2))
res
cbind(res, unadjusted_pval = unadj_pvs)
document()
setwd("Dropbox/coinflibs/")
document()
document()
check()
mean = -0.2
sd = 1
ci_tnorm(mean = mean, sd = sd, limits = int1, alpha = 0.05)
int1
check()
library(intervals)
debug(ci_tnorm)
ci_tnorm(mean = mean, sd = sd, limits = int1, alpha = 0.05)
thisCov
massLower
massUpper
source('~/Dropbox/coinflibs/R/p-value_calculation.R', echo=TRUE)
source('~/Dropbox/coinflibs/R/p-value_calculation.R', echo=TRUE)
debug(ci_tnorm)
ci_tnorm(mean = mean, sd = sd, limits = int1, alpha = 0.05)
massUpper
massLower
pnormstd(limits[limitX,2])
denom
thisCov
massLower
massUpper
massUpper
massLower
thisCov
massLower
limitXa <- limits[limitX,1]
massSmallerXa <- if(limitX!=1)
sum(sapply(1:(limitX-1), function(i)
pnormstd(limits[i,2]) - pnormstd(limits[i,1]))) else 0
massSmallerXa
(massSmallerXa + pnormstd(limitXa))
(massSmallerXa + pnormstd(limitXa))
pnormstd(limits[limitX,1])
nom <- (massSmallerXa + pnormstd(limitXa))
denom <- sum(sapply(1:nrow(limits), function(i) pnormstd(limits[i,2]) - pnormstd(limits[i,1])))
massUpper <- (pnormstd(limits[limitX,2]) - nom) / denom
massLower <- (pnormstd(limits[limitX,1]) - nom) / denom
massUpper
massLower
int2 <- Intervals(c(-2.5,-1))
interval_intersection(int1,int2)
int2 <- Intervals(matrix(c(-3,-2,-1,1), ncol=2, byrow=T))
int2
ci_tnorm(mean = mean, sd = sd, limits = int2, alpha = 0.05)
thisCov
massUpper
massLower
source('~/Dropbox/coinflibs/R/p-value_calculation.R', echo=TRUE)
ci_tnorm(mean = mean, sd = sd, limits = int2, alpha = 0.05)
(int2 <- Intervals(matrix(c(-3,-2,-1,1),
ncol=2, byrow=T)))
ci_tnorm(mean = mean, sd = sd, limits = int2, alpha = 0.05)
debug(ci_tnorm)
ci_tnorm(mean = mean, sd = sd, limits = int2, alpha = 0.05)
massSmallerXa
nom
(pnormstd(limits[limitX,2]) - nom) / denom
(pnormstd(limits[limitX,1]) - nom) / denom
pnormstd(limits[limitX,1]) / denom
(pnormstd(limits[limitX,1]) - nom) / denom
massLower <- (nom - pnormstd(limits[limitX,1])) / denom
massLower
thisQfun <- function(p) qtnorm(p, mean = mean, sd = sd,
lower = limits[limitX, 1],
upper = limits[limitX, 2])
thisCov <- massUpper - massLower
massUpper <- (pnormstd(limits[limitX,2]) - nom) / denom
thisCov <- massUpper - massLower
thisCov
source('~/Dropbox/coinflibs/R/p-value_calculation.R', echo=TRUE)
ci_tnorm(mean = mean, sd = sd, limits = int2, alpha = 0.05)
(int3 <- Intervals(matrix(c(-3,-2,-1.5,1),
ncol=2, byrow=T)))
ci_tnorm(mean = mean, sd = sd, limits = int3, alpha = 0.05)
(int3 <- Intervals(matrix(c(-3,-2,-1.99,1),
ncol=2, byrow=T)))
ci_tnorm(mean = mean, sd = sd, limits = int3, alpha = 0.05)
(int3 <- Intervals(matrix(c(-3,-2.5,-1.9,1),
ncol=2, byrow=T)))
ci_tnorm(mean = mean, sd = sd, limits = int3, alpha = 0.05)
c(ci_tnorm(mean = mean, sd = sd, limits = int3, alpha = 0.05))
ci_tnorm(mean = mean, sd = sd, limits = int3, alpha = 0.05)-mean
document
document()
check()
document()
check()
