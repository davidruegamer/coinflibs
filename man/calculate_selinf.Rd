% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/selinf.R
\name{calculate_selinf}
\alias{calculate_selinf}
\title{Calculate p-values / confidence intervals after likelihood-based or test-based model selection}
\usage{
calculate_selinf(limitObject, y, sd, alpha = 0.05)
}
\arguments{
\item{limitObject}{either an object of \code{class} \code{limitObject} (the result of the
\code{\link{calculate_limits}} function) or a \code{list} of \code{limitObject}s}

\item{y}{response vector}

\item{sd}{standard deviation of error used for the p-value calculation (see details)}

\item{alpha}{value for \code{(1-alpha)}-confidence interval construction. Defaults to \code{0.05}.}
}
\description{
This function takes an \code{limitObject}, which is produced by the 
\code{\link{calculate_limits}} (or a list of \code{limitObject}s) and calculates
the selective p-value / confidence intervals based on the given limitation and the true 
residual standard deviation \code{sd}. Since the true standard deviation is usually unknown in practice
one can plug in an estimate for the true standard deviation. This approach, however,
strongly depends on the goodness of the estimate and in particular produces unreliable results 
if the number of covariates is relatively large in comparison to the number of observations.
}
\examples{


library(MASS)
# Fit initial model
cpus$perf <- log10(cpus$perf)
mod <- lm(perf ~ .-name, data = cpus)

# use the stepAIC function to find the best model in a backward 
# stepwise search
cpus.lm <- stepAIC(mod, trace = FALSE, direction = "backward")

# recalculate all visited models
lom <- c(lapply(colnames(model.matrix(mod)), function(x) 
  update(mod, as.formula(paste0("perf ~ .-", x)))), list(mod))
  
# extract the components of all visited models
compsAIC <- extract_components(listOfModels = lom,
                               response = cpus$perf,
                               what = c("aic"))
                                 
# perform likelihood ratio test at level 
alpha = 0.001

# check for non-significant variables
coefTable <- summary(cpus.lm)$coefficients
drop <- rownames(coefTable)[alpha < coefTable[,4]]

# drop non-significant variable
cpus.lm2 <- update(cpus.lm, as.formula(paste0(".~.-",drop)))

# extract components associated with the LRT comparison
compsLRT <- extract_components(list(cpus.lm, cpus.lm2),
                               response = cpus$perf, 
                               what = "lrt",
                               alpha = alpha)
                               
# naive inference
unadj_pvs <- summary(cpus.lm2)$coefficients[,4]

# now extract testvector, calculate limits and perform selective tests
# test vectors

vTs <- extract_testvec(cpus.lm2)

# calculate limits
limitsAIC <- calculate_limits(compsAIC, vTs)
limitsLRT <- calculate_limits(compsLRT, vTs)

# check restriction on p-values separately
cbind(
calculate_selinf(limitObject = limitsAIC, y = cpus$perf, 
sd = summary(cpus.lm2)$sigma),
unadjusted_pval = unadj_pvs
)

cbind(
calculate_selinf(limitObject = limitsLRT, y = cpus$perf, 
sd = summary(cpus.lm2)$sigma),
unadjusted_pval = unadj_pvs
)

# calculate p-values (does automatically combine limitObjects)
res <- calculate_selinf(limitObject = list(limitsAIC, limitsLRT), 
                       y = cpus$perf, 
                       # plugin estimate for true value
                       sd = summary(cpus.lm2)$sigma)
                       
cbind(res, unadjusted_pval = unadj_pvs)


}
